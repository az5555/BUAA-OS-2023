

# LAB6 challenge报告

### 添加命令和库函数

添加命令要在user/include.mk中USERAPPS下添加对应的.b文件，添加库函要再USERLIB下添加对应的,.o文件。

### 实现过程

> ### 实现一行多命令
>
> 用 `;` 分开同一行内的两条命令，表示**依次**执行前后两条命令。`;` 左右的命令都可以为空。
>
> 提示：在 `user/sh.c` 中的保留 `SYMBOLS` 里已经预留有 `;` 字符。

实现该命令可以通过`fork()`函数来实现，再user/sh.c中，我们有`runcmd()`函数来对命令进行解析，一行多命令的实现，可以参考函数之前实现的重定向来实现。

```c
if ((*rightpipe = fork()) == 0) {
	return argc;
}
else {
	wait(*rightpipe);
return parsecmd(argv, rightpipe);
}

//位于user/lib/wait.c
void wait(u_int envid) {
	volatile struct Env *e;

	e = &envs[ENVX(envid)];
	while (e->env_id == envid && e->env_status != ENV_FREE) {
		syscall_yield();
	}
}
```

其中会使用到`wait()`函数，该函数是已经完成的库函数，作用是阻塞进程，等待进程号与输入进程号相等进程销毁后再释放该进程。这里通过子进程来执行前面的命令，父进程等待子进程完成，然后父进程继续执行后续指令。

> ### 实现后台任务
>
> 用 `&` 分开同一行内的两条命令，表示**同时**执行前后两条命令。`&` 左侧的命令应被置于后台执行，Shell 只等待 `&` 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出。你需要自行设计测试，以展现此功能的运行效果。`&` 左侧的命令不能为空。
>
> 提示：在 `user/sh.c`中的保留 `SYMBOLS` 里已经预留有 `&` 字符。

实现后台任务与实现一行多种命令的过程类似，同样通过`fork()`子进程来完成指令，不过不同点在于后台任务中，不需要阻塞子进程，让子进程在后台完成命令。

##### 测试数据和结果

> ### 现引号支持
>
> 实现引号支持后，shell 可以处理如： `echo.b "ls.b | cat.b"` 这样的命令。即 shell 在解析时，会将双引号内的内容看作单个字符串，将 `ls.b | cat.b` 作为一个参数传递给 `echo.b`。

完成该要求需要了解shell解析命令的全流程，其中，`_gettoken`函数负责解析语意，并且返回地址 ；在这个函数中，我们将`”`单独处理使语法解析器将其认定为字符串直到下一个`“`的输入，并将其作为字符串返回。

```c
if (*s == '"') {
		*s = 0;
		s++;
		*p1 = s;
		while (*s != 0 && *s != '"') {
			s++;
		}
		if (*s == 0) {
			return 0;
		}
else {
	*s = 0;
	s++;
	*p2 = s;
	return 'w';
}

```

> ### 实现键入命令时任意位置的修改
>
> 现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。

~~该部分实现难度很高，不知道为什么放在这么前面。~~要实现这一部分，首先就要了解linux终端对于光标控制实现的原理，以及左右方向键的实质。

- 在我们输入左右光标键时，实际上是输入了连续三个字符分别是`/027``[`以及最后的ABCD，用来描述方向。输入着四个字符后，光标会移动同时利用read函数也能读取这三个字符，我们可以依据这个来进行命令输入任何位置的实现。
  - 上： `27 '[' 'A'`
  - 下： `27 '[' 'B'`
  - 左： `27 '[' 'D'`
  - 右： `27 '[' 'C'`
- 我们对命令字符串的读取，其实是在一个/user/sh.c中的`readline`中实现的，其中的buf字符数组就是我们实际传入解析的字符串，其与我们在终端上看到的字符串并不相同，需要我们来将其进行完善。
- 原来lab6的`readline`函数并不支持时事显示，需要我们将其完全重构来支持输入命令的任意更改和时事显示，我们可以利用两个变量来记载字符总数和光标位置，每当我们更新时都要时事调整光标位置。当我们处于边缘时，也要控制光标防止其越界。在linux中，我们printf`/027``[`和后面的ABCD来控制光标对于的移动，但是有时会出现将这三个字符一起打印出来的bug，由此左右移动建议通过输出`\b`和空格来实现。
- `\b`的作用时将光标前移一格，后面的输出会直接覆盖已有的字符，这和我们平时使用的删除并不相同，由此我们进行输入和删除操作时，要将字符串后面的元素全部打印，再将光标移动到正确的位置上，这一才能实现命令的任意位置的修改。要统一buf内的内容和控制台时事显示的内容。
- buf内容的就是简单字符串的拼接，较为容易实现。

> ### 实现程序名称中 `.b` 的省略
>
> 目前的用户程序被烧录到文件系统中后，其可执行文件以 `.b` 为后缀，为 shell 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 `.b` 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 `.b` 再打开。

`.b`省略的实现可以在/user/lib/spawn.c中的`spawn()`函数中实现，该函数的作用是将程序载入内存并执行，这里我们可以检测传入的文件末尾是否存在.b，若不存在则为其加上.b后缀。实现起来很容易。

> ### 实现更丰富的命令
>
> 参考实验环境中的 Linux 命令 `tree`、`mkdir`、`touch` 来实现这三个命令，请尽可能地实现其完整的功能。
>
> 为了实现文件和目录的创建，你需要实现用户库函数 `mkdir()` 和文件打开模式 `O_CREAT`。
>
> 实现文件的创建后，你需要修改 shell 中输出重定向 `>` 的实现，使其能够在目标路径不存在时自动创建并写入该文件。

实现`mkdir`和`touch`的过程需要创建新的文件服务，要对文件系统进行修改。其中的 `file_create()`函数已经完成，我们只需完成对应的接口。

- 在user/include/fsreq.h 中添加对应的结构体。同时加入一个全新的创建请求。

  ```c
  struct Fsreq_create {
  	u_char req_path[MAXPATHLEN];
  	int req_type;
  };
  
  #define FSREQ_CREATE 8
  ```

- 文件系统端， 在 fs/serv.c中实现`serve_create()`函数。同时，在`serve()`中添加

  ``` c
  case FSREQ_CREATE:
  	serve_create(whom, (struct Fsreq_create *)REQVA);
  break;
  ```

- 在user/include/lib.h中声明`create()`, ` fsipc_create()`函数，然后分别在user/file.c，user/fsipc.c中将其实现

  ```c
  int create(const char* path, int type);
  int fsipc_create(const char*, int);
  ```

  `touch`和`mkdir`的实现创建的文件类型不同，其他完全一致。同时，实现较为简单，不过创建前要检查是否存在该文件。

tree的实现可以通过递归来完成，对目录文件的遍历，可以参考ls.c文件的实现

```c
while ((n = readn(fd, &f, sizeof f)) == sizeof f) {
	if (f.f_name[0]) {
		//do something
	}
}
```

在文件控制块中，也存储了文件的名称，同时加入下一级目录可以通过简单的字符拼接实现。

> ### 实现历史命令功能
>
> 在 Linux 的 shell 中我们输入的命令都会被保存起来，并可以通过 Up 和 Down 键回溯，这为我们的 shell 操作带来了极大的方便。在此项任务中，需要实现保存所有输入至 shell 的命令，并可以通过 `history.b` 命令输出所有的历史命令，以及通过上下键回溯命令并运行。
>
> **任务提示**：
>
> - 要求我们将在 shell 中输入的每步命令，在解析前/后保存进一个专用文件（如 `.history` ）中，每行一条命令。
>
> - 通过编写一个用户态程序 `history.b` 文件并写入磁盘中，使得每次运行 `history.b` 时，能够将文件（ `.history` ）的内容全部输出。
> - 键入 Up 和 Down 时，切换历史命令。键入上下键后，并且按回车，可以执行当前显示的这条命令。

- 为了实现对应功能，可以在user/lib目录中添加history.c文件来存储对应的命令，记得要在user/include/lib中声明对应的函数

  ```c
  //history.c
  void init_history();
  void add_history(char* cmd);
  int next_history(char** str);
  int last_history(char** str);
  int print_all();
  ```

- 对应历史命令的存储，我们可以通过创建一个.history文件来存储，我们需要一个`init_history()`函数，在终端启动时对，.history文件进行初始化。

- 在history.c中创建一系列静态变量，在存储文件的控制块，起始虚拟地址，结束虚拟地址已经目前位置的指针。在添加指令时，对齐进行维护更新。

  ```c
  static int fdnum;
  static char* va;
  static int num;
  static struct Fd *fd;
  static int beginva;
  static char tmp[1024];
  static int endva;
  
  //添加命令时维护
  beginva = (int) fd2data((int) fd);
  endva = beginva + ((struct Filefd*)fd)->f_file.f_size;
  va = (char*)(endva) - 1;
  tmp[0] = 0;
  ```

- 通过`\0`或者`\n`来判断命令的终止和起始。

- 还要再`readline()`中加入up和down的支持。

> ## 选做部分 2：支持相对路径
>
> MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。你需要为每个进程维护**工作目录**这一状态，并为 `open()` 等用户库函数增加对参数中相对路径的支持，将不以 `/` 开头的路径视为相对路径，从当前进程的工作目录开始查找。同时，你需要添加 `chdir()` 和 `getcwd()` 等库函数，以支持切换当前进程的工作目录，并使进程的工作目录在 `fork()` 或 `spawn()` 时被子进程继承，从而实现以下功能：
>
> 1. 支持内部命令 `cd <path>`，切换工作目录到 `<path>`，其中 `<path>` 可以是绝对路径或相对路径；
> 2. 支持 `pwd` 命令，输出当前工作目录；
> 3. 在切换工作目录后，测试 `cat.b`、`ls.b`、`touch.b` 等接受文件参数的命令，确保其参数中的相对路径能够正常工作。

- 相对路径的实现有多种方法，可以利用内存存储工作路径信息也能通过文件系统存储工作目录信息。
- 由于命令的执行是通过fork子进程来实现的，在子进程中的修改无法传达到父进程，由此需要一些其他手段来获取和修改工作目录。

##### 通过系统调用实现

- 若父子进程共用一个工作目录，可以在内核直接创建一个字符串来存储工作目录。通过系统调用来修改和获取相对路径。
- 若每个进程都有工作目录，则需要在PCB中添加相对路径，此时，需要子进程来修改父进程的工作目录，为了实现该功能可能需要实现父子进程间的通讯。要注意修改进程的初始化和fork时子进程的初始化。

##### 通过文件来实现

- 若父子进程共用一个工作目录，可以直接通过文件来实现工作目录的存储和修改，实现起来相对容易。
- 若每个进程都有工作目录，可以利用进程编号来识别进程，但是要修改的地方过多，及其复杂，不建议这样做。

要记得修改`cat`，`ls`，`tree`，`touch`，`cd`,`mkdir`等命令的相对路径支持，要注意特殊的`.`和`..`目录。

### 心得体会

在本次lab6的challenge中，我们在没有注释和指导书的帮助下完成了诸多功能，实现了一个较为高级的shell，在这个过程中，我查阅了大量的资料，了解到了很多有关linux的相关知识，同时耗费了大量时间来完成对应的功能。可以说，既有痛苦，同时收获也很多，大大加深了我对操作系统的了解。